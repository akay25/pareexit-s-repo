# Git & GitHub

# installing git on the system using terminal

sudo apt install git  --> for installation

git --version  --> for checking version of git

# config

git config --global user.email "pareexit.baldaniya@innvonix.in"  --> used to store email of the user
git config --global user.name "Pareexit Baldaniya"  --> used to store email of the user

git config --list  --> show all settings that have changed

# staging

git init  --> create a new folder on system and initialize it as a git repository

git add <file> <file2>  --> used to add updated folder into git repository
git add .  --> . is used for saving all the files at a time

git status  --> current state of repository

# commit

git commit -m "commit message"  --> -m is used to add a message ti the commit  --> commit is a way to save the changes to repository

git status

git log  --> show the history of the repo

# gitignore  --> used to ignore files and folders

# git push origin main  --> push updated files/folders to the GitHub

# SSH Key:
-> used for directly connect to the GitHub without supplying token or user details every time.
-> using this SSH Key to sign commits

# SSH v/s HTTPS keys difference:

1. SSH
-> SSH is a secure because it uses key pair and need to add it to GitHub
-> no need of login credentials everytime
-> for cloning a repository it needs a private key

2. HTTPS
-> need of login credentials everytime
-> anyone can clone repositories

# git clone  --> use for cloning the repository

# steps to update data on GitHub

1. git status
2. git add <filename>
3. git commit -m "<message>"
4. git push origin main
+--------------------------------------------------------------------------------------------------------------------+

# Variables and data types:

1. str = ("Hello world")
2. int = 1,2,3
3. float = 3.0, 5.0
4. boolean = True
5. list = ['a','b','c']
6. tuple = ('1','2','3')
7. complex = 2 + 4j

+--------------------------------------------------------------------------------------------------------------------+

# control flow:

1. if
-> used to execute block of code if specific condition is true

Ex.
a = 5
if a == 5
print("a is equal to 5")

2. if-else
-> used to execute block of code if specific condition is true, and another block of code is false

Ex.
x = 3
y = 4
if x == y:
    print("x is equal to y)
else:
    print("x is not equal to y)

3. if-else-if
-> used to execute block of code if specific condition is true, another block of code if another condition is true, and a default block if other is not true

Ex.
a = 15

if a == 5:
    print("a is equal to 5")
elif a == 10:
    print("a is equal to 10")
else:
    print("a is not equal to 5 or 10")

4. Ternary operator
-> used to assign a value to a variable based on a condition.

Ex.
a = 10

print("a is equal to 5" if a == 5 else "a is not equal to 5")

+--------------------------------------------------------------------------------------------------------------------+

# Functions:

-> block of code which only runs when it is called
-> avoid code repetition

--> Syntax

def functionName():
    # code

Ex.
def get_greetings():
    return "Hello from a function"

message = get_greetings
print(message)

# lambda function:
-> used to define anonymous function in Python
-> can take any no. of arguments, but can only have one expression

Ex.
s1 = "Hello"
s2 = lambda a: a.upper()
print(s2(s1))

+--------------------------------------------------------------------------------------------------------------------+

# Data Structure:

1. List []: ordered, mutable
-> index starting with 0 and ends with n-1

Ex.
list = ["a","b","c"]  --> multiple values
list1 = [["o","p"],["q"]]  --> multi-dimentional list

# Methods:

1. list.append()  --> add element at the end of the list
2. list.clear()  --> remove all the elements
3. list.sort()  --> sorts the list
4. list.insert()  --> adds an element to the specific position
5. list.cout()  --> count the elements present in the list
6. list.copy()  --> returns a copy of the list
7. list.extend()  --> add more list at the end of the current list
8. list.remove()  --> removes the element with the specified value

# List Comprehension:
-> offers a shorter syntax to create new list based on existing list

Ex.

fruits = ['apple', 'banana', 'mango', 'kiwi', 'guava', 'pears']
newList = []

for x in fruits:
    if 'a' in x:
    newList.append(x)

print(newList)


2. Tuple (): ordered, immutable
-> need a trailing 'comma' to make it tuple
-> index starting with 0 and ends with n-1

Ex.
Tuple = ('a','b')  --> tuple using string

list1 = [1,2,3]  
tuple = tuple(list1)  --> tuple using list

# Methods:

1. tuple.count()  --> returns a number of times a specified value occurs in tuple
2. tuple.index()  --> search and give the position no. of a perticular tuple


3. Dict {}: unordered, immutable
-> it holds a key:value pair

Ex. 
dict = {'name': 'xyz', 'b': 2}

# Methods:

1. dict.clear()  --> remove all the elements from the dictionary
2. dict.copy()  --> returns a copy of the dictionary 
3. dict.pop()  --> removes the  element with the specific key
4. dict.update()  --> update the dictionary with the specified key-value pair
5. dict.values()  --> returns a list of all the value in the dictionary


4. Set (): unordered, mutable, not allowed duplicates
-> used for eliminate duplicate entries

Ex.
set = set([1,2,2,3,4,4,5])  --> o/p - 1,2,3,4,5

# Methods:

1. set.add()  --> adds an element
2. set.union()  --> returns a set containing union of sets
3. set.update()  --> update the set with the union of this set and other
4. set.clear()  --> removes all the elements from the set
5. set.discard()  -->remove the specified item

+--------------------------------------------------------------------------------------------------------------------+

# Error handling:

# errors and exception

--> syntax of the exception handling:

try:
    # code
except SomeException:
    # code
except SomeException:
    # code
else:
    # code
finally:
    # code

--> some types of the error/exceptions:

1. ZeroDivisionError
2. ValueError
3. SyntaxError
4. ArithmaticError, etc...

Note: best practice is to identify the specific errors in place of generally getting tha errors/exceptions

+--------------------------------------------------------------------------------------------------------------------+

# File handling:

-> performing some operations on file like, opening, reading, writing and closing.

--> Syntax:

file = open('file1.txt', 'r')
content = file.read()
file.close()

with open('file1.txt', 'w') as file:  --> with statement automatically close the file
    file.write("Hello")

print("File written successfully")

+--------------------------------------------------------------------------------------------------------------------+

# Modules:

-> file containing Python code

-> three types:
1. built-in
-> already built in the python

Ex.
import math  --> import entire module
print(math.sqrt(25))

2. user-defined
-> this are the Python files created by users, used in different parts of the project

Ex.
from math import sqrt, pi  --> import specific item from a module 
print(sqrt(25))
print(pi)

3. External(Third Party)
-> need to install it using package managers like pip

Ex.
import math as m  --> import with an alis
print(m.sqrt(25))

+--------------------------------------------------------------------------------------------------------------------+

# OOPs:

+--------------------------------------------------------------------------------------------------------------------+

# Generator/Iterator:

1. Iterators:
-> it remembers a place while moving through a collection
-> list, string, dict, set, tuple all are iterables
-> whenever we runs a for loop it secretly convert tha tlist into iterator
-> it can grab items one by one

# Methods:

1. iter()  --> converts item into iterator
2. next()  --> grab the next item, once item grabbed, it's gone from the queue

Ex.
fruits = ['apple', 'banana', 'cherry']
item = iter(fruits)

print(next(item))  --> o/p = apple
print(next(item))  --> o/p = banana
print(next(item))  --> o/p = cherry
print(next(item))  --> o/p = StopIteration error

2. Generators:
-> a simple way to generate a iterator using function

# Methods:

1. yield()  --> it is like pause and handover button

Ex.
def count_to_two():
    yield 1
    yield 2
    yield 3

generator = count_to_two()

print(next(generator))  --> o/p = 1
print(next(generator))  --> o/p = 2

+--------------------------------------------------------------------------------------------------------------------+

# Decorators:
-> decorators are function that takes function and return it with some additional functionalities
-> it is a wrapper funtion that modifies the behaviour
-> use '@' symbol for assigning a decorator to the function 

Ex.
def greetings(func):
    def wrapper():  --> nested function
        print("Hello!")
        func()
        print("How are you?")
    return wrapper

@my_decorator
def world():
    print(", World")

print(world)
--> o/p = Hello!, World  --> before function runs, decorator works
          How are you?  --> after function run, decorator not works

+--------------------------------------------------------------------------------------------------------------------+

# List operations:
-> functional programming tools

1. map():
-> used when apply a specific function to every item

# syntax
map(function, iterable)

Ex.
num = [1, 2, 3, 4]
doubled = list(map(lambda x: x * 2, numbers))

2. filter():
-> used to extract item with a specific condition from an iterator

# syntax
fliter(function, iterable)

Ex.
num = [1, 2, 3, 4, 5, 6]
even = list(filter(lambda x: x % 2 == 0, numbers))

3. reduce():
-> reduce a list to a single value by applying a rolling computation
-> need to import from functools module

# syntax
from functools import reduce

numbers = [1, 2, 3, 4]
product = reduce(lambda x, y : x * y, numbers) --> o/p = 24


+--------------------------------------------------------------------------------------------------------------------+

# Virtual Environment(venv):
-> it's an isolated working directory

# use:
-> conflict prevention  --> saperate dependencies for defferent project
-> no admin rights  --> install any packages without sudo and admin permission
-> Reproducibility  --> easily share which library is needed for project

# lifecycle of the venv:

1. Create the environment:
$ python -m venv .vene

2. Activate the environment:
$ source .venv/bin/activate

3. Install packages:
$ pip install ...

4. Deactivate:
$ Deactivate

--> best practice is to never commit .venv folder to the git

+--------------------------------------------------------------------------------------------------------------------+

# Dependency Management(pip):
-> standard package installer
-> installing libraries and dependencies from PyPI
-> at the installation time it is basic dependency manager, not an advanced one

# How pip manages dependencies

1. Installation  --> install all required packages and its dependencies
2. Dependency resolution  --> check for compitible version
3. Version planning and Reproducibility  --> managing dependencies
4. Virtual environment  --> used to seperately install the dependencies

+--------------------------------------------------------------------------------------------------------------------+

# Debugging Tools(pdb - The Python Debugger):
-> tool for Debugging python program
-> it allows to set breakpoints, step through code, inspect varibles, and control execution flow

# How to start pdb:

1. Insert a breakpoint in code
-> use the built-in function point (Python 3.7+)
-> insert import pdb; pdb.set_trace() at the desired line
-> at the execution time it stops here and open pdb prompt

2. from the command line
-> run script under debugger using the -m flag
$ python -m pdb script.py

3. Post-mortem():
-> to inspect the state after program crash
$ pdb.post_mortem() or pdb.pm()

+--------------------------------------------------------------------------------------------------------------------+

# Collaboration(Conflict Resolver):
-> collaboration happens when multiple people working on the same file at the same time
-> at that time git act as a traffic controller
-> conflict happens when multiple people change and commit exact same line of code in different way
-> to resolve it conflict resolver is used

# Merge conflict
-> developer 1 change one line of code and developer 2 also change the same line of code
-> when they combine their work, git gives error

# How to resolve it

1. find the markers:
'<<<<<<<' HEAD  --> start of conflict 
print("hello from developer 1")
'======='  --> divider between two line
print("hello from developer 2")
'>>>>>>>' branch-name  --> end of conflict

2. choose the winner:
-> we can choose either keep version 1 or version 2 or both

3. finalize:
git add <file_name>
git commit -m "<message>"
+--------------------------------------------------------------------------------------------------------------------+